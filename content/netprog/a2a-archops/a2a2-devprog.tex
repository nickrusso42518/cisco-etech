\subsection{Device programmability}
An Application Programmability Interface (API) is meant to define a standard
way of interfacing with a software application or operating system. It may
consist of functions (methods, routines, etc), protocols, system call
constructs, and other ``hooks'' for integration. Both the controllers and
business applications would need the appropriate APIs revealed for integration
between the two. This makes up the northbound communication path as discussed
in section 2.1.5. By creating a common API for communications between
controllers and business applications, either one can be changed at any time
without significantly impacting the overall architecture.

A common API that is discussed within the networking world is the
Representational State Transfer (REST) API\@. REST represents an ``architectural
style'' of transferring information between clients and servers. In essence, it
is a way of defining attributes or characteristics of how data is moved. REST
is commonly used with HTTP by combining traditional HTTP methods (GET, POST,
PUT, DELETE, etc) and Universal Resource Identifiers (URI). The end result is
that API requests look like URIs and are used to fetch/write specific pieces
of data to a target machine. This simplification helps promote automation,
especially for web-based applications or services. Note that HTTP is stateless
which means the server does not store session information for individual
flows; REST API calls retain this stateless functionality as well. This allows
for seamless REST operation across HTTP proxies and gateways.

\subsubsection{Google Remote Procedure Call (gRPC) on IOS-XR using iosxr\_grpc}
Google defined gRPC as gRPC Remote Procedure Call framework, borrowing the
idea of recursive acronyms popular in the open source world. The RPC concept
is not a new one; Distributed Component Object Model (DCOM) from Microsoft has
long existed, among others. These RPC mechanisms are both highly complex and
considered legacy today. Despite its utility, gRPC is open source and free at
the time of this writing.

gRPC attempts to solve a number of shortcomings of REST-based APIs. For
example, there is no formal machine definition of a REST API\@. Each API is
custom-built following REST architectural principles. API consumers must
always read documents pertaining to the specific API in order to determine its
usage specifications. Furthermore, streaming operations (sending a stream of
messages in response to a client's request, or vice versa) are very difficult
as HTTP 1.1, the specification upon which most REST-based APIs are built, does
not support this. Instead, gRPC is based on HTTP/2 which supports this
functionality.

The gRPC framework also solves the time-consuming and expensive problem of
writing client libraries. With REST-based APIs, individual client libraries
must be written in whatever language a developer needs for gRPC API
invocations. Using the Interface Definition Language (IDL), which is loosely
analogous to YANG, developers can identify both the service interface and the
structure of the payload messages. Because IDL follows a standard format (it's
a language after all), it can be compiled. The outputs from this compilation
process include client libraries for many different languages, such as C, C\#,
Java, and Python to name a few.

Error reporting in gRPC is also improved when compared to REST-based APIs.
Rather than relying on generic HTTP status codes, gRPC has a formalized set of
errors specific to API usage, which is better suited to machine-based
communications. To facilitate this communication technique, gRPC forms a
single TCP session with many API calls transported within; this allows
multiple in-flight API calls concurrently.

Today, gRPC is supported on Cisco's IOS-XR platform. To follow this
demonstration, any Linux development platform will work, assuming it has
Python installed. Testing gRPC on IOS-XR is not particularly different than
other APIs, but requires many setup steps. Each one is covered briefly before
the demonstration begins. First, install the necessary underlying libraries
needed to use gRPC\@. The ``docopt'' package helps with using CLI commands and is
used by the Cisco IOS-XR \verb|cli.py| client.

\begin{minted}{text}
[root@devbox ec2-user]# pip install grpcio docopt
Collecting grpcio
  Downloading
[snip]
Collecting docopt
  Downloading
[snip]
\end{minted}

Next, install the Cisco IOS-XR specific libraries needed to communicate using
gRPC\@. This could be bundled into the previous step, but was separated in this
document for cleanliness.

\begin{minted}{text}
[root@devbox ec2-user]# pip install iosxr_grpc
Collecting iosxr_grpc
[snip]
\end{minted}

Clone this useful gRPC client library, written by Karthik Kumaravel. It
contains a number of wrapper functions to simplify using gRPC for both
production and learning purposes. Using the \verb|ls| command, ensure the
\verb|ios-xr-grpc-python/| directory has files in it. This indicates a successful
clone. More skilled developers may skip this step and write custom Python code
using the \verb|iosxr_grpc| library directly.

\begin{minted}{text}
[root@devbox ec2-user]# git clone \
>  https://github.com/cisco-grpc-connection-libs/ios-xr-grpc-python.git
Cloning into 'ios-xr-grpc-python'...
remote: Counting objects: 419, done.
remote: Total 419 (delta 0), reused 0 (delta 0), pack-reused 419
Receiving objects: 100% (419/419), 99.68 KiB | 0 bytes/s, done.
Resolving deltas: 100% (219/219), done.

[root@devbox ec2-user]# ls ios-xr-grpc-python/
examples  iosxr_grpc  LICENSE  README.md  requirements.txt  setup.py  tests
\end{minted}

To better understand how the data modeling works, clone the YANG models
repository. To save download time and disk space, one could specify a more
targeted clone. Use \verb|ls| again to ensure the clone operation succeeded.

\begin{minted}{text}
[root@devbox ec2-user]# git clone https://github.com/YangModels/yang.git
Cloning into 'yang'...
remote: Counting objects: 13479, done.
remote: Total 13479 (delta 0), reused 0 (delta 0), pack-reused 13478
Receiving objects: 100% (13479/13479), 22.93 MiB | 20.26 MiB/s, done.
Resolving deltas: 100% (9244/9244), done.
Checking out files: 100% (12393/12393), done.

[root@devbox ec2-user]# ls yang/
experimental  ieee802-dot1ab-lldp.yang  README.md  setup.py  [snip]
\end{minted}

Install the pyang tool, which is a Python utility for managing YANG models.
This same tool is used to examine YANG models in conjunction with NETCONF on
IOS-XE elsewhere in this book.

\begin{minted}{text}
[root@devbox ec2-user]# pip install pyang
Collecting pyang
  Downloading
[snip]
[root@devbox ec2-user]# which pyang
/bin/pyang
\end{minted}

Using pyang, examine the YANG model on IOS-XR for OSPFv3, which is the topic
of this demonstration. This tree structure defines the JSON representation of
the device configuration that gRPC requires. NETCONF uses XML encoding and
gRPC uses JSON encoding, but both are the exact same representation of the
data structure.

\begin{minted}{text}
[root@devbox ec2-user]# cd yang/vendor/cisco/xr/631/
[root@devbox 631]# pyang -f tree Cisco-IOS-XR-ipv6-ospfv3-cfg.yang
module: Cisco-IOS-XR-ipv6-ospfv3-cfg
  +--rw ospfv3
     +--rw processes
     |  +--rw process* [process-name]
     |     +--rw default-vrf
     |     |  +--rw ldp-sync?                      boolean
     |     |  +--rw prefix-suppression?            boolean
     |     |  +--rw spf-prefix-priority-disable?   empty
     |     |  +--rw area-addresses
     |     |  |  +--rw area-address* [address]
     |     |  |  |  +--rw address                inet:ipv4-address-no-zone
     |     |  |  |  +--rw authentication
     |     |  |  |  |  +--rw enable?      boolean
[snip]
\end{minted}

Before continuing, ensure you have a functional IOS-XR platform running
version 6.0 or later. Log into the IOS-XR platform via SSH and enable gRPC\@.
It's very simple and only requires identifying a TCP port on which to listen.
Additionally, TLS-based security options are available but omitted for this
demonstration. This IOS-XR platform is an XRv9000 running in AWS on version 6.3.1.

\begin{minted}{text}
RP/0/RP0/CPU0:XRv_gRPC#show version                  
Cisco IOS XR Software, Version 6.3.1
Copyright (c) 2013-2017 by Cisco Systems, Inc.

Build Information:
 Built By     : ahoang
 Built On     : Wed Sep 13 18:30:01 PDT 2017
 Build Host   : iox-ucs-028
 Workspace    : /auto/srcarchive11/production/6.3.1/xrv9k/workspace
 Version      : 6.3.1
 Location     : /opt/cisco/XR/packages/

cisco IOS-XRv 9000 () processor 
System uptime is 21 minutes

RP/0/RP0/CPU0:XRv_gRPC#show running-config grpc 
grpc
 port 10033
!
\end{minted}

Once enabled, check the gRPC status and statistics, respectively, to ensure it
is running. The TCP port is 10033 and TLS is disabled for this test. The
statistics do not show any gRPC activity yet. This makes sense since no API
calls have been executed.

\begin{minted}{text}
RP/0/RP0/CPU0:XRv_gRPC#show grpc status
*************************show gRPC status**********************
---------------------------------------------------------------
transport                       :     grpc
access-family                   :     tcp4
TLS                             :     disabled
trustpoint                      :     NotSet
listening-port                  :     10033
max-request-per-user            :     10
max-request-total               :     128
vrf-socket-ns-path              :     global-vrf
_______________________________________________________________
*************************End of showing status*****************

RP/0/RP0/CPU0:XRv_gRPC#show grpc statistics 
*************************show gRPC statistics******************
---------------------------------------------------------------
show-cmd-txt-request-recv       :     0
show-cmd-txt-response-sent      :     0
get-config-request-recv         :     0
get-config-response-sent        :     0
cli-config-request-recv         :     0
cli-config-response-sent        :     0
get-oper-request-recv           :     0
get-oper-response-sent          :     0
merge-config-request-recv       :     0
merge-config-response-sent      :     0
commit-replace-request-recv     :     0
commit-replace-response-sent    :     0
delete-config-request-recv      :     0
delete-config-response-sent     :     0
replace-config-request-recv     :     0
replace-config-response-sent    :     0
total-current-sessions          :     0
commit-config-request-recv      :     0
commit-config-response-sent     :     0
action-json-request-recv        :     0
action-json-response-sent       :     0
_______________________________________________________________
*************************End of showing statistics*************
\end{minted}

Manually configure some OSPFv3 parameters via CLI to start. Below is a
configuration snippet from the IOS-XRv platform running gRPC\@.

\begin{minted}{text}
RP/0/RP0/CPU0:XRv_gRPC#show running-config router ospfv3
router ospfv3 42518
 router-id 10.10.10.2
 log adjacency changes detail
 area 0
  interface Loopback0
   passive
  !
  interface GigabitEthernet0/0/0/0
   cost 1000
   network point-to-point
   hello-interval 1
  !
 !
 address-family ipv6 unicast
\end{minted}

Navigate to the \verb|examples/| directory inside of the cloned IOS-XR gRPC client
utility. The \verb|cli.py| utility can be run directly from the shell with a
handful of CLI arguments to specify the username/password, TCP port, and gRPC
operation. Performing a \verb|get-config| operation first will return the
properly-structured JSON of the entire configuration. Because it is so long,
the author redirects this into a file for further processing. The JSON shown
below is also truncated for brevity.

\begin{minted}{text}
[root@devbox ec2-user]# cd ios-xr-grpc-python/examples/
[root@devbox examples]# ./cli.py -i xrv_grpc -p 10033 -u root -pw grpctest \
>  -r get-config | tee json/ospfv3.json
\end{minted}
\begin{minted}{json}
{
 "data": {
  "Cisco-IOS-XR-ip-static-cfg:router-static": {
   "default-vrf": {
    "address-family": {
     "vrfipv4": {
      "vrf-unicast": {
       "vrf-prefixes": {
        "vrf-prefix": [
\end{minted}

Using the popular \verb|jq| (JSON query) utility, one can pull out the OSPFv3
configuration from the file.

\begin{minted}{text}
[root@devbox examples]# jq '.data."Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3"' json/ospfv3.json 
\end{minted}
\begin{minted}{json}
{
  "processes": {
    "process": [
      {
        "process-name": 42518,
        "default-vrf": {
          "router-id": "10.10.10.2",
          "log-adjacency-changes": "detail",
          "area-addresses": {
            "area-area-id": [
              {
                "area-id": 0,
                "enable": [
                  null
                ],
                "interfaces": {
                  "interface": [
                    {
                      "interface-name": "Loopback0",
                      "enable": [
                        null
                      ],
                      "passive": true
                    },
                    {
                      "interface-name": "GigabitEthernet0/0/0/0",
                      "enable": [
                        null
                      ],
                      "cost": 1000,
                      "network": "point-to-point",
                      "hello-interval": 1
                    }
                  ]
                }
              }
            ]
          }
        },
        "af": {
          "af-name": "ipv6",
          "saf-name": "unicast"
        },
        "enable": [
          null
        ]
      }
    ]
  }
}
\end{minted}

Run the \verb|jq| command again except redirect the output to a new file. This new
file represents the configuration updates to be pushed via gRPC\@.

\begin{minted}{text}
[root@devbox examples]# jq '.data."Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3"' \
>  json/ospfv3.json >> json/merge.json
\end{minted}

Using a text editor, manually update the \verb|merge.json| file by adding the
top-level key of ``Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3'' and changing some
minor parameters. In the example below, the author updates Gig0/0/0 cost,
network type, and hello interval. Don't forget the trailing \verb|}| at
the bottom of the file after adding the top-level key discussed above or else
the JSON data will be syntactically incorrect.

\begin{minted}{text}
[root@devbox examples]# cat json/merge.json 
\end{minted}
\begin{minted}{json}
{
  "Cisco-IOS-XR-ipv6-ospfv3-cfg:ospfv3": {
    "processes": {
      "process": [
        {
          "process-name": 42518,
          "default-vrf": {
            "router-id": "10.10.10.2",
            "log-adjacency-changes": "detail",
            "area-addresses": {
              "area-area-id": [
                {
                  "area-id": 0,
                  "enable": [
                    null
                  ],
                  "interfaces": {
                    "interface": [
                      {
                        "interface-name": "Loopback0",
                        "enable": [
                          null
                        ],
                        "passive": true
                      },
                      {
                        "interface-name": "GigabitEthernet0/0/0/0",
                        "enable": [
                          null
                        ],
                          "cost": 123,
                          "network": "broadcast",
                          "hello-interval": 17
                      }
                    ]
                  }
                }
              ]
            }
          },
          "af": {
            "af-name": "ipv6",
            "saf-name": "unicast"
          },
          "enable": [
            null
          ]
        }
      ]
    }
  }
}
\end{minted}

Use the \verb|cli.py| utility again except with the \verb|merge-config|
option. Specify the \verb|merge.json| file as the configuration delta to merge
with the existing configuration. This API call does not return any output, but
checking the return code indicates it succeeded.

\begin{minted}{text}
[root@devbox examples]# ./cli.py -i xrv_grpc -p 10033 -u root -pw grpctest \
>  -r merge-config --file json/merge.json

\begin{minted}{text}
[root@devbox examples]# echo #?
0
\end{minted}

Log into the IOS-XR platform again and confirm via CLI that the configuration was updated.

\begin{minted}{text}
RP/0/RP0/CPU0:XRv_gRPC#sh run router ospfv3
router ospfv3 42518
 router-id 10.10.10.2
 log adjacency changes detail
 area 0
  interface Loopback0
   passive
  !
  interface GigabitEthernet0/0/0/0
   cost 123
   network broadcast
   hello-interval 17
  !
 !
 address-family ipv6 unicast
\end{minted}

The gRPC statistics are updated as well. The first \verb|get-config| request came
from the devbox and the response was sent from the router. The same
transactional communication is true for \verb|merge-config|.

\begin{minted}{text}
RP/0/RP0/CPU0:XRv_gRPC#show grpc statistics 
*************************show gRPC statistics******************
---------------------------------------------------------------
show-cmd-txt-request-recv       :     0
show-cmd-txt-response-sent      :     0
get-config-request-recv         :     1
get-config-response-sent        :     1
cli-config-request-recv         :     0
cli-config-response-sent        :     0
get-oper-request-recv           :     0
get-oper-response-sent          :     0
merge-config-request-recv       :     1
merge-config-response-sent      :     1
commit-replace-request-recv     :     0
commit-replace-response-sent    :     0
delete-config-request-recv      :     0
delete-config-response-sent     :     0
replace-config-request-recv     :     0
replace-config-response-sent    :     0
total-current-sessions          :     0
commit-config-request-recv      :     0
commit-config-response-sent     :     0
action-json-request-recv        :     0
action-json-response-sent       :     0
_______________________________________________________________
*************************End of showing statistics*************
\end{minted}

\subsubsection{gRPC on IOS-XR using grpcio and Manual Compilation}
The previous section introduced gRPC but masked much of the complexity
within the \verb|iosxr_grpc| package. Sometimes, individual client libraries
do not exist, and programmers must generate their own based on a
\verb|.proto| service defintion file. As discussed earlier, gRPC
differs from REST because it defines a clear set of operations
that are supported between client and server. Below is an example
service definition file for the Cisco IOS-XR router (v6.3.1). The
\verb|gRPCConfigOper| service describes the RPCs available to the client,
along with their arguments and return values. The arguments and return
values are called ``messages'' and are defined later in the file. Most of
these objects are simple with only a few fields, such as ``yangjson'' or
``errors''. These \verb|proto| files should be supplied by the vendor;
in this case, check Cisco's documentation for your current IOS-XR version
to find the corresponding protocol definition file. This section focuses
less on basic gRPC enablement and YANG models and more on the
inner workings of gRPC itself.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# cat xr.proto
\end{minted}

\begin{minted}{protobuf}
syntax = "proto3";

package IOSXRExtensibleManagabilityService;

service gRPCConfigOper {
    rpc GetConfig(ConfigGetArgs) returns(stream ConfigGetReply) {};
    rpc MergeConfig(ConfigArgs) returns(ConfigReply) {};
    rpc DeleteConfig(ConfigArgs) returns(ConfigReply) {};
    rpc ReplaceConfig(ConfigArgs) returns(ConfigReply) {};
    rpc CliConfig(CliConfigArgs) returns(CliConfigReply) {};
    rpc CommitReplace(CommitReplaceArgs) returns (CommitReplaceReply) {};
    rpc CommitConfig(CommitArgs) returns(CommitReply) {};
    rpc ConfigDiscardChanges(DiscardChangesArgs) returns(DiscardChangesReply) {};
    rpc GetOper(GetOperArgs) returns(stream GetOperReply) {};
    rpc CreateSubs(CreateSubsArgs) returns(stream CreateSubsReply) {};
}
service gRPCExec {
    rpc ShowCmdTextOutput(ShowCmdArgs) returns(stream ShowCmdTextReply) {};
    rpc ShowCmdJSONOutput(ShowCmdArgs) returns(stream ShowCmdJSONReply) {};
    rpc ActionJSON(ActionJSONArgs) returns(stream ActionJSONReply) {};
}
message ConfigGetArgs {
    int64 ReqId = 1;
    string yangpathjson = 2;
}
message ConfigGetReply {
    int64 ResReqId = 1;
    string yangjson = 2;
    string errors = 3;
}
message GetOperArgs {
    int64 ReqId = 1;
    string yangpathjson = 2;
}
message GetOperReply {
    int64 ResReqId = 1;
    string yangjson = 2;
    string errors = 3;
}
message ConfigArgs {
    int64 ReqId = 1;
    string yangjson = 2;
}
message ConfigReply {
    int64 ResReqId = 1;
    string errors = 2;
}
message CliConfigArgs {
    int64 ReqId = 1;
    string cli = 2;
}
message CliConfigReply {
    int64 ResReqId = 1;
    string errors = 2;
}
message CommitReplaceArgs {
    int64 ReqId = 1;
    string cli = 2;
    string yangjson = 3;
}
message CommitReplaceReply {
    int64 ResReqId = 1;
    string errors = 2;
}
message CommitMsg {
    string label = 1;
    string comment = 2;
}
enum CommitResult {
    CHANGE = 0;
    NO_CHANGE = 1;
    FAIL = 2;
}
message CommitArgs {
    CommitMsg msg = 1;
    int64 ReqId = 2;
}
message CommitReply {
    CommitResult result = 1;
    int64 ResReqId = 2;
    string errors = 3;
}
message DiscardChangesArgs {
    int64 ReqId = 1;
}
message DiscardChangesReply {
    int64 ResReqId = 1;
    string errors = 2;
}
message ShowCmdArgs {
    int64 ReqId = 1;
    string cli = 2;
}
message ShowCmdTextReply {
    int64 ResReqId = 1;
    string output = 2;
    string errors = 3;
}
message ShowCmdJSONReply {
    int64 ResReqId = 1;
    string jsonoutput = 2;
    string errors = 3;
}
message CreateSubsArgs {
    int64 ReqId = 1;
    int64 encode = 2;
    string subidstr = 3;
}
message CreateSubsReply {
    int64 ResReqId = 1;
    bytes data = 2;
    string errors = 3;
}
message ActionJSONArgs {
    int64 ReqId = 1;
    string yangpathjson = 2;
}
message ActionJSONReply {
    int64 ResReqId = 1;
    string yangjson = 2;
    string errors = 3;
}
\end{minted}



To get started, we must install two gRPC-related packages which allow us
to create the required Python code from a gRPC \verb|.proto| file.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# pip install grpcio grpcio-tools
Collecting grpcio
Collecting grpcio-tools
(snip)
Successfully installed grpcio-1.34.0 grpcio-tools-1.34.0
\end{minted}

With the proper tools installed, we must ``compile'' the \verb|xr.proto| file
which yields two output files. One file is \verb|xr_pb2.py| which defines
the request and response objects, such as \verb|ConfigArgs| and
\verb|ConfigReply|. These objects represent the input and output data
structures used by gRPC for a specific platform, providing a clear
and well-defined contract of communications. The second file is
\verb|xr_pb2_grpc.py| which defines gRPC client and server interfaces.
In our case, the server is the IOS-XR device, so we have little use for it
at present, but it might be useful for CI/CD testing or offline development.
The compilation process is only one command, but I've created a small Bash
script to summarize the process and the artifacts.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# cat compile.sh
#!/bin/bash
# Compiles the protobuf definition and generates two Python files
#  1. xr_pb2.py: generated request and response classes
#  2. xr_pb2_grpc.py: generated client and server classes
python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. xr.proto

Nicholass-MBP:grpc_xr nicholasrusso# ./compile.sh
Nicholass-MBP:grpc_xr nicholasrusso#
\end{minted}

After compilation, the two Python files are present alongside the original
protobuf-defined service file. We can include these in our Python scripts.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# ls -1 xr*
xr.proto
xr_pb2.py
xr_pb2_grpc.py
\end{minted}

Let's quickly explore the attributes and methods in each Python module. From
the Python REPL, we \verb|import xr_pb2| to view the request and response
objects available. Some unrelated items have been omitted for brevity.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python
>>> import xr_pb2
>>> dir(xr_pb2)
['ActionJSONArgs', 'ActionJSONReply', 'CliConfigArgs', 'CliConfigReply',
'CommitArgs', 'CommitMsg', 'CommitReplaceArgs', 'CommitReplaceReply',
'CommitReply', 'CommitResult', 'ConfigArgs', 'ConfigGetArgs',
'ConfigGetReply', 'ConfigReply', 'CreateSubsArgs', 'CreateSubsReply',
'DiscardChangesArgs', 'DiscardChangesReply',  'GetOperArgs', 'GetOperReply',
'ShowCmdArgs', 'ShowCmdJSONReply', 'ShowCmdTextReply', (snip)]
\end{minted}

Repeat the process for the second module using \verb|import xr_pb2_grpc|.
This one contains the client and service interface objects. For our demo,
the \verb|gRPCConfigOperStub| feature is most important to us.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python
>>> import xr_pb2_grpc
>>> dir(xr_pb2_grpc)
['gRPCConfigOper', 'gRPCConfigOperServicer', 'gRPCConfigOperStub',
'gRPCExec', 'gRPCExecServicer', 'gRPCExecStub', (snip)]
\end{minted}

Next, let's create a simple Python class that exposes a subset of the
gRPC functionality. We'll limit it to the CRUD operations, allowing
us to perform a variety of basic configuration management tasks. The
\verb|__enter__()| and \verb|__exit__()| methods allow instances of this
class to act as context managers, simplifying the process of connecting
and disconnecting. As seen earlier in our review of \verb|xr.proto|,
the \verb|GetConfig| RPC returns a stream of \verb|ConfigGetReply|
objects, making it slightly different than the other RPCs. The others
all consume \verb|ConfigArgs| and return \verb|ConfigReply| objects.
Note that while gRPC helps formalize the client/service communications,
it still relies on YANG-modeled data, much like NETCONF and RESTCONF\@.
This is best handled using Python structures (dictionaries, lists, etc.)
and converting them to strings as required by the gRPC service definition.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# cat cisco_xr_grpc.py
\end{minted}

\begin{minted}{python}
#!/usr/bin/env python

"""
Author: Nick Russo
Purpose: Define a simple Cisco IOS-XR gRPC interface using OOP.
"""

import json
import grpc
import xr_pb2
import xr_pb2_grpc

class CiscoXRgRPC:
    """
    Define a simple Cisco IOS-XR gRPC interface using OOP.
    """

    def __init__(self, host, port, username, password):
        """
        Create a new object with the specific hostname/IP, gRPC port,
        username, and password.
        """
        self.creds = [("username", username), ("password", password)]
        self.host = host
        self.port = port

    def __enter__(self):
        """
        Establish a gRPC connection to the device and instantiate the
        stub object from which RPCs can be issued.
        """
        self.channel = grpc.insecure_channel(f"{self.host}:{self.port}")
        self.stub = xr_pb2_grpc.gRPCConfigOperStub(self.channel)
        return self

    def __exit__(self, type, value, traceback):
        """
        Gracefully close the gRPC connection.
        """
        self.channel.close()

    def _make_config_args(self, data):
        """
        Internal-only method to create a ConfigArgs object based
        on a YANG-modeled Python dictionary.
        """
        return xr_pb2.ConfigArgs(yangjson=json.dumps(data))

    def get_config(self, yangpathjson_dict):
        """
        Issue a GetConfig RPC and transform result into a list of
        ConfigGetReply objects for each consumption.
        """
        responses = self.stub.GetConfig(
            xr_pb2.ConfigGetArgs(yangpathjson=json.dumps(yangpathjson_dict)),
            metadata=self.creds,
        )
        return [json.loads(resp.yangjson) for resp in responses if resp.yangjson]

    def merge_config(self, yangjson_dict):
        """
        Issue a MergeConfig RPC based on the YANG data supplied.
        """
        response = self.stub.MergeConfig(
            self._make_config_args(yangjson_dict), metadata=self.creds
        )
        return response

    def replace_config(self, yangjson_dict):
        """
        Issue a ReplaceConfig RPC based on the YANG data supplied.
        """
        response = self.stub.ReplaceConfig(
            self._make_config_args(yangjson_dict), metadata=self.creds
        )
        return response

    def delete_config(self, yangjson_dict):
        """
        Issue a DeleteConfig RPC based on the YANG data supplied.
        """
        response = self.stub.DeleteConfig(
            self._make_config_args(yangjson_dict), metadata=self.creds
        )
        return response
\end{minted}

Next, let's create a test script that leverages this new class. This script
behaves like a quick-and-dirty CLI tool for testing, providing options for
GetConfig, MergeConfig, ReplaceConfig, and DeleteConfig operations. The
\verb|xr1| device is available in a free, publicly-accessible sandbox
hosted by Cisco DevNet. Readers can replace the credential information
as required to suit their test environments.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# cat grpc_config.py
\end{minted}

\begin{minted}{python}
#!/usr/bin/env python

"""
Author: Nick Russo
Purpose: Test the CiscoXRgRPC class using the IOS-XR DevNet sandbox.
"""

import argparse
import json
from cisco_xr_grpc import CiscoXRgRPC

def main(args):
    """
    CiscoXRgRPC tests begin here.
    """

    # Define connectivity information for Cisco DevNet sandbox XR1
    xr1 = {
        "host": "10.10.20.70",
        "port": 57021,
        "username": "admin",
        "password": "admin",
    }

    # Open a new connection to XR1 by unpacking dict into kwargs
    with CiscoXRgRPC(**xr1) as conn:

        # Issue GetConfig RPC
        if args.getconfig:
            vrf_path = {"Cisco-IOS-XR-infra-rsi-cfg:vrfs": [None]}
            response = conn.get_config(yangpathjson_dict=vrf_path)

            # Response is a list of ConfigGetReply objects
            for resp in response:
                for vrf in resp["Cisco-IOS-XR-infra-rsi-cfg:vrfs"]["vrf"]:

                    # Print VRF summary output for simple confirmation. Example:
                    # VRF name: A / RTI 1:1 RTE 1:1
                    print(f"VRF name: {vrf['vrf-name']} /", end="")
                    bgp = vrf["afs"]["af"][0]["Cisco-IOS-XR-ipv4-bgp-cfg:bgp"]
                    rti = bgp["import-route-targets"]["route-targets"]
                    rte = bgp["export-route-targets"]["route-targets"]
                    ihalf = rti["route-target"][0]["as-or-four-byte-as"][0]
                    ehalf = rte["route-target"][0]["as-or-four-byte-as"][0]
                    print(f" RTI {ihalf['as']}:{ihalf['as-index']}", end="")
                    print(f" RTE {ehalf['as']}:{ehalf['as-index']}")

        # Issue MergeConfig RPC
        if args.mergeconfig:
            with open("vrf_b.json", "r") as handle:
                vrf_b = json.load(handle)
            response = conn.merge_config(yangjson_dict=vrf_b)
            print(f"Errors: {response.errors if response.errors else 'N/A'}")

        # Issue ReplaceConfig RPC
        if args.replaceconfig:
            with open("vrf_b.json", "r") as handle:
                vrf_b = json.load(handle)
            response = conn.replace_config(yangjson_dict=vrf_b)
            print(f"Errors: {response.errors if response.errors else 'N/A'}")

        # Issue DeleteConfig RPC
        if args.deleteconfig:
            vrf_b = {
                "Cisco-IOS-XR-infra-rsi-cfg:vrfs": {"vrf": [{"vrf-name": "B"}]}
            }
            response = conn.delete_config(yangjson_dict=vrf_b)
            print(f"Errors: {response.errors if response.errors else 'N/A'}")

if __name__ == "__main__":

    # Define CLI arguments for Get, Merge, Replace, and Delete operations
    parser = argparse.ArgumentParser()
    parser.add_argument("-g", "--getconfig", action="store_true")
    parser.add_argument("-m", "--mergeconfig", action="store_true")
    parser.add_argument("-r", "--replaceconfig", action="store_true")
    parser.add_argument("-d", "--deleteconfig", action="store_true")

    # Pass arguments into the main() function for evaluation
    main(parser.parse_args())
\end{minted}

To begin, we'll add VRF A to the router manually using SSH\@. This will
give us something to collect using \verb|GetConfig|. Keeping things
simple, each VRF in this demo will only use a single AFI and single
pair of route-targets.

\begin{minted}{text}
RP/0/RP0/CPU0:r1#show running-config vrf
vrf A
 address-family ipv4 unicast
  import route-target
   1:1
  export route-target
   1:1
\end{minted}

Running the script using the \verb|-g| option, this instructs Python
to connect using gRPC and issue the \verb|GetConfig| RPC\@. The script
hardcodes the YANG path to \verb|{"Cisco-IOS-XR-infra-rsi-cfg:vrfs": [None]}|
which collects all VRFs on the device. Each VRF is compressed to a single
line of over-simplified output for demo purposes.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -g
VRF name: A / RTI 1:1 RTE 1:1
\end{minted}

Next, let's add VRF B, a new VRF defined in a JSON file. This structure
follows the IOS-XR ``native'' YANG model, which is extremely hierarchical.
The VRF imports and exports route-target 2:2 with no other attributes set.
You can review the IOS-XR YANG models for your current software version
\href{https://github.com/YangModels/yang/tree/master/vendor/cisco/xr}{here}.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# cat vrf_b.json
\end{minted}

\begin{minted}{json}
{
  "Cisco-IOS-XR-infra-rsi-cfg:vrfs": {
    "vrf": [
      {
        "vrf-name": "B",
        "afs": {
          "af": [
            {
              "af-name": "ipv4",
              "saf-name": "unicast",
              "topology-name": "default",
              "Cisco-IOS-XR-ipv4-bgp-cfg:bgp": {
                "import-route-targets": {
                  "route-targets": {
                    "route-target": [
                      {
                        "type": "as",
                        "as-or-four-byte-as": [
                          {
                            "as-xx": 0,
                            "as": 2,
                            "as-index": 2,
                            "stitching-rt": 0
                          }
                        ]
                      }
                    ]
                  }
                },
                "export-route-targets": {
                  "route-targets": {
                    "route-target": [
                      {
                        "type": "as",
                        "as-or-four-byte-as": [
                          {
                            "as-xx": 0,
                            "as": 2,
                            "as-index": 2,
                            "stitching-rt": 0
                          }
                        ]
                      }
                    ]
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
}
\end{minted}

The script is hardcoded to load the JSON data from this file into a
a Python dictionary. The \verb|MergeConfig| RPC includes this data as
an argument, effectively adding it to the configuration. Per the
services definition, the response only contains an ``errors'' attribute.
When no errors occur, it is set to the empty string, so the script prints
``N/A'' when no errors occur. Otherwise, the error string is displayed. To
confirm that the merge succeeded, we'll run another \verb|GetConfig| RPC
immediately afterwards to confirm VRFs A and B exist.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -m
Errors: N/A

Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -g
VRF name: A / RTI 1:1 RTE 1:1
VRF name: B / RTI 2:2 RTE 2:2
\end{minted}

The \verb|ReplaceConfig| operation will overwrite the existing VRFs with
whatever is specified in the supplied \verb|ConfigArgs| object. We can
delete all VRFs other than VRF B using this approach when we supply the
same JSON input file. After the replacement, only VRF B remains.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -r
Errors: N/A

Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -g
VRF name: B / RTI 2:2 RTE 2:2
\end{minted}

Last, we can delete VRF B by specifying it by name in a \verb|DeleteConfig|
RPC\@. It is not necessary to specify the entire VRF B payload. Now, there
are no VRFs remaining as evidenced by an lack of \verb|GetConfig| responses.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -d
Errors: N/A
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -g
Nicholass-MBP:grpc_xr nicholasrusso#
\end{minted}

Note that if you try to delete a nonexistent object, gRPC will raise an
error, which is in JSON format. In this example, VRF B has already
been deleted and so cannot be deleted again.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_config.py -d
Errors: {
 "cisco-grpc:errors": {
  "error": [
   {
    "error-type": "application",
    "error-tag": "data-missing",
    "error-severity": "error",
    "error-path": "Cisco-IOS-XR-infra-rsi-cfg:ns1:vrfs/ns1:vrf[vrf-name='B']"
   }
  ]
 }
}
\end{minted}

In addition to configuration management, we can also collect streaming
telemetry using the \verb|CreateSubs| RPC\@. This leverages gRPC in a dial-in
design whereby the router dynamically accepts connections from collectors.
On the router, the author has pre-configured a sample telemetry subscription
which collects memory statistics. This periodic subscription will yield a new
measurement every 10,000 milliseconds (10 seconds).

\begin{minted}{text}
RP/0/RP0/CPU0:r1#show running-config telemetry model-driven
telemetry model-driven
 sensor-group mem
  sensor-path Cisco-IOS-XR-nto-misc-oper:memory-summary/nodes/node/summary
 subscription sub1
  sensor-group-id mem sample-interval 10000
\end{minted}

We'll update our \verb|cisco_xr_grpc.py| module with a new \verb|Encode|
class to enumerate the variety of telemetry formats supported by IOS-XR\@.
These formats are discussed more later. Additionally, we'll create a method
to create a new subscription using the proper RPC and proper arguments. The
\verb|create_subs()| method will block indefinitely or until the connection
is broken, constantly listening for telemetry updates.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# cat cisco_xr_grpc.py
\end{minted}

\begin{minted}{python}
from enum import IntEnum

class Encode(IntEnum):
    """
    Enumerated encoding types for streaming telemetry.
    This isn't well documented today ...
    """
    TEST = 1
    GPB = 2
    KVGPB = 3
    JSON = 4

class CiscoXRgRPC:

    # snip; other methods omitted for brevity

    def create_subs(self, sub_id, encode):
        """
        Subscribe to a telemetry topic using a specific encoding
        (see Encode class for options) and unique subscription ID.
        Returns a generator object which is built as messages arrive.
        """
        sub_args = xr_pb2.CreateSubsArgs(ReqId=1, encode=encode, subidstr=sub_id)
        stream = self.stub.CreateSubs(sub_args, metadata=self.creds)
        for segment in stream:
            yield segment
\end{minted}

Next, we'll create a new script to test the telemetry subscriptions
which is separate from the configuration management script. We can continue
to use the \verb|xr1| device, except this time, we'll establish a telemetry
subscription using JSON encoding for readability.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# cat grpc_telemetry.py
\end{minted}

\begin{minted}{python}
#!/usr/bin/env python

"""
Author: Nick Russo
Purpose: Test the CiscoXRgRPC telemetry subscription functionality.
"""

from cisco_xr_grpc import CiscoXRgRPC, Encode

def main():
    """
    Test the CiscoXRgRPC telemetry subscription functionality.
    """

    # Define connectivity information for Cisco DevNet sandbox XR1
    xr1 = {
        "host": "10.10.20.70",
        "port": 57021,
        "username": "admin",
        "password": "admin",
    }

    # Open a new connection to XR1 by unpacking dict into kwargs
    with CiscoXRgRPC(**xr1) as conn:

        # Collect telemetry responses using JSON for readability
        responses = conn.create_subs("sub1", encode=Encode.JSON)
        for response in responses:
            print(response)

if __name__ == "__main__":
    main()
\end{minted}

Running the script for at least 20 seconds, you'll see some telemetry
metrics collected and displayed as a giant JSON structure enclosed
in a string. In a real application, one might parse this information
for further analysis, ultimately displaying it on a dashboard.

\begin{minted}{text}
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_telemetry.py
ResReqId: 3
data: "{"node_id_str":"r1","subscription_id_str":"sub1","encoding_path":
"Cisco-IOS-XR-nto-misc-oper:memory-summary/nodes/node/summary","collection_id":3,
"collection_start_time":1608911695372,"msg_timestamp":1608911695387,"data_json":
[{"timestamp":1608911695386,"keys":{"node-name":"0/RP0/CPU0"},"content":
{"page-size":4096,"ram-memory":5368709120,"free-physical-memory":640364544,
"system-ram-memory":5368709120,"free-application-memory":726900736,
"image-memory":4194304,"boot-ram-size":0,"reserved-memory":0,"io-memory":0,
"flash-system":0}},{"timestamp":1608911695395,"keys":{"node-name":"0/0/CPU0"},
"content":{"page-size":4096,"ram-memory":8589934592,"free-physical-memory":
6210064384,"system-ram-memory":8589934592,"free-application-memory":6296834048,
"image-memory":4194304,"boot-ram-size":0,"reserved-memory":0,"io-memory":0,
"flash-system":0}}],"collection_end_time":1608911695399}"

ResReqId: 3
data: "{"node_id_str":"r1","subscription_id_str":"sub1","encoding_path":
"Cisco-IOS-XR-nto-misc-oper:memory-summary/nodes/node/summary","collection_id":4,
"collection_start_time":1608911705405,"msg_timestamp":1608911705437,"data_json":
[{"timestamp":1608911705437,"keys":{"node-name":"0/RP0/CPU0"},"content":
{"page-size":4096,"ram-memory":5368709120,"free-physical-memory":634781696,
"system-ram-memory":5368709120,"free-application-memory":721137664,
"image-memory":4194304,"boot-ram-size":0,"reserved-memory":0,"io-memory":0,
"flash-system":0}},{"timestamp":1608911705442,"keys":{"node-name":"0/0/CPU0"},
"content":{"page-size":4096,"ram-memory":8589934592,"free-physical-memory":
6210449408,"system-ram-memory":8589934592,"free-application-memory":6296985600,
"image-memory":4194304,"boot-ram-size":0,"reserved-memory":0,"io-memory":0,
"flash-system":0}}],"collection_end_time":1608911705443}"
\end{minted}

Before breaking the connecting with Control-C, you can verify that the
session is active by running the following command on the IOS-XR device.
This reveals the current dial-in connection information for confirmation.

\begin{minted}{text}
RP/0/RP0/CPU0:r1#show telemetry model-driven subscription
Subscription:  sub1                     State: ACTIVE
-------------
  Sensor groups:
  Id                               Interval(ms)        State
  mem                              10000               Resolved

  Destination Groups:
  Id            Encoding   Transport   State   Port    Vrf     IP
  DialIn_1002   json       dialin      Active  37588           192.168.122.1
    No TLS
\end{minted}

For completeness, here are the outputs from the remaining formats. The ``test''
option is for connectivity verification only and is effectively a null/empty
encoding. Google Protocol Buffers, or GPB, is a compact, binary-only format
that is very high performance but is generally not human readable. Key/value
GPB is a hybrid of GBP and JSON, allowing keys to be human readable but
dictionaries are encoded in binary for improved performance. As seen earlier,
JSON is the easiest to read but is the worst performing given that it is
pure text.

\begin{minted}{text}
# Using test encoding
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_telemetry.py
(no output)

# Using GPB encoding
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_telemetry.py
ResReqId: 5
data:
"\n\002r1\032\004sub12<Cisco-IOS-XR-nto-misc-oper:memory-summary/nodes/node/summary:
\n2015-11-09@\010H\262\315\360\325\351.P\262\315\360\325\351.h\302\315\360\325\351.b
\224\001\nI\010\271\315\360\325\351.R\014\n\n0/RP0/CPU0Z2\220\003\200 \230\003\200\200\200\200\024\240\003\200\200\366\272\002\250\003\200\200\200\200
\024\260\003\200\340\227\344\002\270\003\200\200\200\002\300\003\000\310\003\000
\320\003\000\330\003\000\nG\010\300\315\360\325\351.R\n\n\0100/0/CPU0Z2\220\003
\200 \230\003\200\200\200\200 \240\003\200\200\236\221\027\250\003\200\200\200\200 \260\003\200\340\277\272\027\270\003\200\200\200\002\300\003\000\310\003
\000\320\003\000\330\003\000"

# Using KV-GPB encoding
Nicholass-MBP:grpc_xr nicholasrusso# python grpc_telemetry.py
ResReqId: 6
data:
"\n\002r1\032\004sub12<Cisco-IOS-XR-nto-misc-oper:memory-summary/nodes/node/summary:
\n2015-11-09@\tH\370\223\361\325\351.P\370\223\361\325\351.Z\220\002\010\203\224\361
\325\351.z\037\022\004keysz\027\022\tnode-name*\n0/RP0/CPU0z\345\001\022\007contentz
\016\022\tpage-size8\200z\022\022\nram-memory@\200\200\200\200\024z\034\022\024
free-physical-memory@\200\300\347\272\002z\031\022\021system-ram-memory@
\200\200\200\200\024z\037\022\027free-application-memory@\200\240\211\344\002z
\023\022\014image-memory@\200\200\200\002z\021\022\rboot-ram-size@\000z\023\022
\017reserved-memory@\000z\r\022\tio-memory@\000z\020\022\014flash-system@\000Z\216
\002\010\206\224\361\325\351.z\035\022\004keysz\025\022\tnode-name*\0100/0/CPU0z\345
\001\022\007contentz\016\022\tpage-size8\200 z\022\022\nram-memory@\200\200\200\200z
\034\022\024free-physical-memory@\200\300\246\221\027z\031\022\021system-ram-memory@
\200\200\200\200z\037\022\027free-application-memory@\200\240\310\272\027z\023\022
\014image-memory@\200\200\200\002z\021\022\rboot-ram-size@\000z\023\022
\017reserved-memory@\000z\r\022\tio-memory@\000z\020\022\014flash-system@\000h
\210\224\361\325\351."
\end{minted}

Feel free to explore these scripts or expand upon them to suit your needs.

\subsubsection{Python paramiko Library on IOS-XE}
Many of the traditional scripts that network engineers have written to
interact with devices have used Python's paramiko library. Before simplified
wrapper tools like Ansible, networkers could interact with a network device
shell by sending raw commands and receiving byte strings in return. The
mechanics are generally simple but less elegant than modern tools. This brief
demonstration uses paramiko to both collect information from, and push
information to, a Cisco CSR1000v running in AWS\@. The relevant version and
package information is listed below. You may need to use pip to install paramiko.

\begin{minted}{text}
[ec2-user@devbox ~]# python3 --version
Python 3.6.5

[ec2-user@devbox ~]# python3 -m pip list | grep paramiko
paramiko (2.4.2)
\end{minted}

Below is the code for the demonstration. The comments included in-line help
explain what is happening at a basic level. The file is \verb|cisco_paramiko.py|.

\begin{minted}{python}
import time
import paramiko

def send_cmd(conn, command):
    """
    Given an open connection and a command, issue the command and wait
    500 ms for the command to be processed.
    """
    conn.send(command + '\n')
    time.sleep(0.5)

def get_output(conn):
    """
    Given an open connection, read all the data from the buffer and
    decode the byte string as UTF-8.
    """
    return conn.recv(65535).decode('utf-8')

def main():
    """
    Execution starts here by creating an SSHClient object, assigning login
    parameters, and opening a new shell via SSH.
    """
    conn_params = paramiko.SSHClient()
    conn_params.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    conn_params.connect(hostname='172.31.31.144', port=22,
                        username='python', password='python',
                        look_for_keys=False, allow_agent=False)

    conn = conn_params.invoke_shell()
    print(f'Logged into {get_output(conn).strip()} successfully')

    # Run some exec commands and print the output, including
    # prompt returns and newlines.
    commands = ['terminal length 0', 'show version', 'show inventory']
    for command in commands:
        send_cmd(conn, command)
        print(get_output(conn))

    # Run some configuration commands after issuing "conf t" and
    # discard the output. Issue "end" afterwards
    services = ['service nagle', 'service sequence-numbers', 'service dhcp']
    send_cmd(conn, 'configure terminal')
    for service in services:
        send_cmd(conn, service)
    send_cmd(conn, 'end')

if __name__ == '__main__':
    main()
\end{minted}

Before running this code, examine the configuration of the router's services.
Notice that DHCP is explicitly disabled while nagle and sequence-numbers are
disabled by default.

\begin{minted}{text}
CSR1000V#show running-config | include service
service timestamps debug datetime msec
service timestamps log datetime msec
no service dhcp
\end{minted}

Run the script using the command below, which logs into the router, gathers
some basic information, and applies some configuration updates.

\begin{minted}{text}
[ec2-user@devbox ~]# python3 cisco_paramiko.py
Logged into CSR1000V# successfully
terminal length 0
CSR1000V#
show version
Cisco IOS XE Software, Version 16.09.01
Cisco IOS Software [Fuji], Virtual XE Software (X86_64_LINUX_IOSD-UNIVERSALK9-M),
  Version 16.9.1, RELEASE SOFTWARE (fc2)
[version output truncated]
Configuration register is 0x2102

CSR1000V#
show inventory
NAME: "Chassis", DESCR: "Cisco CSR1000V Chassis"
PID: CSR1000V          , VID: V00  , SN: 9CZ120O2S1L

NAME: "module R0", DESCR: "Cisco CSR1000V Route Processor"
PID: CSR1000V          , VID: V00  , SN: JAB1303001C

NAME: "module F0", DESCR: "Cisco CSR1000V Embedded Services Processor"
PID: CSR1000V          , VID:      , SN:

CSR1000V#
\end{minted}

After running this code, all three specified services are enabled. DHCP does
not show up because it is enabled by default, but \verb|no service dhcp| is
absent, implying \verb|service dhcp| is enabled.
 
\begin{minted}{text}
CSR1000V#show running-config | include service
service nagle
service timestamps debug datetime msec
service timestamps log datetime msec
service sequence-numbers
\end{minted}

\subsubsection{Python netmiko Library on IOS-XE}
While paramiko is relatively easy to use, especially with simple wrapper
functions for sending commands and reading output, it has some weaknesses.
First, it is unlikely that network engineers care about seeing the exec shell
prompt, the echoed command, and flurry of whitespace that accompanies much of
the data written to the receive buffer. Additionally, specifying a buffer read
size, measured in bytes, to pull data from the shell session is a low-level
operation that could be abstracted. The netmiko library expands on the
capabilities of paramiko specifically for network engineers. This library was
created and is currently maintained by
\href{https://pynet.twb-tech.com/blog/automation/netmiko.html}{Kirk Byers}.
It serves as the base networking library for
\href{https://github.com/networktocode/ntc-ansible}{Network To Code (NTC) Ansible modules}
and is popular in the network automation community, even for traditional Python
coders. The version and package information is below. The netmiko package can
be installed using pip.

\begin{minted}{text}
[ec2-user@devbox ~]# python3 --version
Python 3.6.5

[ec2-user@devbox ~]# python3 -m pip list | grep netmiko
netmiko (2.3.0)
\end{minted}

Below is the code for the demonstration. Like the paramiko example, comments
included in-line help explain the steps. Notice that there is significantly
less code, and the code that does exist is relatively simple and abstract. The
code accomplishes the same general tasks as the paramiko code. The file is
\verb|cisco_netmiko.py|.

\begin{minted}{python}
from netmiko import ConnectHandler

def main():
    """
    Execution starts here by creating a new connection with several
    keyword arguments to log into the device.
    """
    conn = ConnectHandler(device_type='cisco_ios', ip='172.31.31.144',
                          username='python', password='python')

    print(f'Logged into {conn.find_prompt()} successfully')

    # Run some exec commands and print the output, but don't need
    # to define a custom function to send commands cleanly
    commands = ['terminal length 0', 'show version', 'show inventory']
    for command in commands:
        print(conn.send_command(command))

    # Run some configuration commands, don't need "conf t" anymore
    # and don't need to build our own for loop
    services = ['service nagle', 'service sequence-numbers', 'service dhcp']
    conn.send_config_set(services)

if __name__ == '__main__':
    main()
\end{minted}

For completeness, below is a snippet of the services currently enabled. Just
like in the paramiko example, the three services we want to enable (DHCP,
nagle, and sequence-numbers) are currently disabled.

\begin{minted}{text}
CSR1000V#show running-config | include service
service timestamps debug datetime msec
service timestamps log datetime msec
no service dhcp
\end{minted}

Running the code, there is far less output since netmiko cleanly masks the
shell prompt from being returned with each command output, instead only
returning the relevant/useful data.

\begin{minted}{text}
[ec2-user@devbox ~]# python3 cisco_netmiko.py
Logged into CSR1000V# successfully

Cisco IOS XE Software, Version 16.09.01
Cisco IOS Software [Fuji], Virtual XE Software (X86_64_LINUX_IOSD-UNIVERSALK9-M),
  Version 16.9.1, RELEASE SOFTWARE (fc2)
[snip]

Configuration register is 0x2102

NAME: "Chassis", DESCR: "Cisco CSR1000V Chassis"
PID: CSR1000V          , VID: V00  , SN: 9CZ120O2S1L

NAME: "module R0", DESCR: "Cisco CSR1000V Route Processor"
PID: CSR1000V          , VID: V00  , SN: JAB1303001C

NAME: "module F0", DESCR: "Cisco CSR1000V Embedded Services Processor"
PID: CSR1000V          , VID:      , SN:
\end{minted}

After running this code, all three specified services in the services list are
automatically configured with minimal effort. Recall that \verb|service dhcp|
is enabled by default.

\begin{minted}{text}
CSR1000V#show running-config | include service
service nagle
service timestamps debug datetime msec
service timestamps log datetime msec
service sequence-numbers
\end{minted}

\subsubsection{NETCONF using netconf-console on IOS-XE}
YANG as a modeling language was discussed earlier in this document. This was
lacking context because YANG by itself provides little value. There needs to
be some mechanism to transport the data that conforms to these
machine-friendly models. One of those transport options is NETCONF\@.

This section explores a short NETCONF/YANG example using Cisco CSR1000v on
modern \verb|Everest| software. This router is running as an EC2 instance inside
AWS\@. Using the EIGRP YANG model explored earlier in this document, this
section demonstrates configuration updates relating to EIGRP\@.

The simplest way to enable NETCONF/YANG is with the \verb|netconf-yang| global
command with no additional arguments.

\begin{minted}{text}
NETCONF_TEST#show running-config | include netconf
netconf-yang
\end{minted}

RFC6242 describes NETCONF over SSH and TCP port 830 has been assigned for this
service. A quick test of the \verb|ssh| shell command on port 830 shows a
successful connection with several lines of XML being returned. Without
understanding what this data means, the names of several YANG modules are
returned, including the EIGRP one of interest.

\begin{minted}{text}
Nicholass-MBP:ssh nicholasrusso# ssh -p 830 nctest@netconf.njrusmc.net
nctest@netconf.njrusmc.net's password:
\end{minted}

\begin{minted}{xml}
<?xml version="1.0" encoding="UTF-8"?>
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
<capabilities>
<capability>urn:ietf:params:netconf:base:1.0</capability>
<capability>urn:ietf:params:netconf:base:1.1</capability>
<capability>urn:ietf:params:netconf:capability:writable-running:1.0</capability>
<capability>urn:ietf:params:netconf:capability:xpath:1.0</capability>
<capability>urn:ietf:params:netconf:capability:validate:1.0</capability>
[snip]
<capability>http://cisco.com/ns/yang/Cisco-IOS-XE-eigrp?module=Cisco-IOS-XE-eigrp&amp;
revision=2017-02-07</capability>
[snip]
\end{minted}

The \verb|netconf-console.py| tool is a simple way to interface with network
devices that use NETCONF\@. This is the same tool used in the Cisco blog post
mentioned earlier. Rather than specify basic SSH login information as command
line arguments, the author suggests editing these values in the Python code to
avoid typos while testing. These options begin around line 540 of the
\verb|netconf-console.py| file.

\begin{minted}{python}
parser.add_option("-u", "--user", dest="username", default="nctest",
                  help="username")
parser.add_option("-p", "--password", dest="password", default="nctest",
                  help="password")
parser.add_option("--host", dest="host", default="netconf.njrusmc.net",
                  help="NETCONF agent hostname")
parser.add_option("--port", dest="port", default=830, type="int",
                  help="NETCONF agent SSH port")
\end{minted}

Run the playbook using Python 2 (not Python 3, as the code is not
syntactically compatible) with the \verb|--hello| option to collect the list of
supported capabilities from the router. Verify that the EIGRP module is
present. This output is similar to the native SSH shell test from above except
it is handled through the \verb|netconf-console.py| tool.

\begin{minted}{text}
Nicholass-MBP:YANG nicholasrusso# python netconf-console.py --hello
\end{minted}

\begin{minted}{xml}
<?xml version="1.0" encoding="UTF-8"?>
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <capabilities>
    <capability>urn:ietf:params:netconf:base:1.0</capability>
    <capability>urn:ietf:params:netconf:base:1.1</capability>
    <capability>urn:ietf:params:netconf:capability:writable-running:1.0</capability>
    <capability>urn:ietf:params:netconf:capability:xpath:1.0</capability>
    <capability>urn:ietf:params:netconf:capability:validate:1.0</capability>
    <capability>urn:ietf:params:netconf:capability:validate:1.1</capability>
    <capability>urn:ietf:params:netconf:capability:rollback-on-error:1.0</capability>
    <capability>[snip, many capabilities here]</capability>
    <capability>http://cisco.com/ns/yang/Cisco-IOS-XE-eigrp?module=Cisco-IOS-XE-eigrp&amp;
	revision=2017-02-07</capability>
  </capabilities>
  <session-id>26801</session-id>
</hello>
\end{minted}

This device claims to support EIGRP configuration via NETCONF as verified
above. To simplify the initial configuration, an EIGRP snippet is provided
below which adjusts the variables in scope for this test. These are CLI
commands and are unrelated to NETCONF\@.

\begin{minted}{text}
# Applied to NETCONF_TEST router
router eigrp NCTEST
 address-family ipv4 unicast autonomous-system 65001
  af-interface GigabitEthernet1
   bandwidth-percent 9
   hello-interval 7
   hold-time 8
\end{minted}

When querying the router for this data, start at the topmost layer under the
data field and drill down to the interesting facts. The text below shows the
current \verb|router eigrp| configuration on the device using the
\verb|--get-config -x| option set. Omitting any options and simply using
\verb|--get-config| will provide the entire configuration, which is useful for
finding out what the structure of the different CLI stanzas are.

\begin{minted}{text}
Nicholass-MBP:YANG nicholasrusso# python netconf-console.py \
>  --get-config -x "native/router/eigrp"
\end{minted}

\begin{minted}{xml}
 <?xml version="1.0" encoding="UTF-8"?>
 <rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="1">
   <data>
     <native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native">
       <router>
         <eigrp xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-eigrp">
           <id>NCTEST</id>
           <address-family>
             <type>ipv4</type>
             <af-ip-list>
               <unicast-multicast>unicast</unicast-multicast>
               <autonomous-system>65001</autonomous-system>
               <af-interface>
                 <name>GigabitEthernet1</name>
                 <bandwidth-percent>9</bandwidth-percent>
                 <hello-interval>7</hello-interval>
                 <hold-time>8</hold-time>
               </af-interface>
             </af-ip-list>
           </address-family>
         </eigrp>
       </router>
     </native>
   </data>
 </rpc-reply>
\end{minted}

Next, a small change will be applied using NETCONF\@. Each of the three
variables will be incremented by 10. Simply copy the \verb|eigrp| data field from
the remote procedure call (RPC) feedback, save it to a file
(\verb|eigrp-updates.xml| for example), and hand-modify the variable values.
Correcting the indentation by removing leading whitespace is not strictly
required but is recommended for readability. Below is an example of the
configuration parameters that NETCONF can push to the device.

\begin{minted}{text}
Nicholass-MBP:YANG nicholasrusso# cat eigrp-updates.xml
\end{minted}

\begin{minted}{xml}
<native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native">
  <router>
    <eigrp xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-eigrp">
      <id>NCTEST</id>
      <address-family>
        <type>ipv4</type>
        <af-ip-list>
          <unicast-multicast>unicast</unicast-multicast>
          <autonomous-system>65001</autonomous-system>
          <af-interface>
            <name>GigabitEthernet1</name>
            <bandwidth-percent>19</bandwidth-percent>
            <hello-interval>17</hello-interval>
            <hold-time>18</hold-time>
          </af-interface>
        </af-ip-list>
      </address-family>
    </eigrp>
  </router>
</native>
\end{minted}

Using the \verb|--edit-config| option, write these changes to the device. NETCONF
will return an \verb|ok| message when complete.

\begin{minted}{text}
Nicholass-MBP:YANG nicholasrusso# python netconf-console.py \
>  --edit-config=./eigrp-updates.xml
\end{minted}

\begin{minted}{xml}
<?xml version="1.0" encoding="UTF-8"?>
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="1">
  <ok/>
</rpc-reply>
\end{minted}

Perform the \verb|get| operation once more to ensure the value were updated
correctly by NETCONF\@.
 
\begin{minted}{text}
Nicholass-MBP:YANG nicholasrusso# python netconf-console.py \
>  --get-config -x "native/router/eigrp"
\end{minted}

\begin{minted}{xml}
<?xml version="1.0" encoding="UTF-8"?>
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="1">
  <data>
    <native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native">
      <router>
        <eigrp xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-eigrp">
          <id>NCTEST</id>
          <address-family>
            <type>ipv4</type>
            <af-ip-list>
              <unicast-multicast>unicast</unicast-multicast>
              <autonomous-system>65001</autonomous-system>
              <af-interface>
                <name>GigabitEthernet1</name>
                <bandwidth-percent>19</bandwidth-percent>
                <hello-interval>17</hello-interval>
                <hold-time>18</hold-time>
              </af-interface>
            </af-ip-list>
          </address-family>
        </eigrp>
      </router>
    </native>
  </data>
</rpc-reply>
\end{minted}

Logging into the router's shell via SSH as a final check, the configuration
changes made by NETCONF were retained. Additionally, a syslog message suggests
that the configuration was updated by NETCONF, which helps differentiate it
from regular CLI changes.

\begin{minted}{text}
%DMI-5-CONFIG_I:  F0: nesd:  Configured from NETCONF/RESTCONF by nctest, transaction-id 81647

NETCONF_TEST#show running-config | section eigrp
router eigrp NCTEST
 !
 address-family ipv4 unicast autonomous-system 65001
  !
  af-interface GigabitEthernet1
   bandwidth-percent 19
   hello-interval 17
   hold-time 18
\end{minted}

\subsubsection{NETCONF using Python and jinja2 on IOS-XE}
While the netconf-console.py utility is an easy way to explore using NETCONF,
a more realistic application of the technology includes custom programming.
The Python library \verb|ncclient|, or NETCONF client for short, provides an
easily-consumable NETCONF API for Python programmers. The following program
was written by \href{https://twitter.com/dmfigol}{Dmitry Figol} and was
slightly modified by the author to fit this book's format and style. Comments
are included throughout the code to provide high-level explanations of the
process. In a sentence, the code collects the running configuration and prints
some basic system data, then adds some new loopbacks to the router. The file
is called \verb|pynetconf.py|.

\begin{minted}{python}
#!/usr/bin/python3
import jinja2
import xmltodict
from ncclient import manager

def get_config(connection_params):
    # Open connection using the parameter dictionary
    with manager.connect(**connection_params) as connection:
        config_xml = connection.get_config(source='running').data_xml
        config = xmltodict.parse(config_xml)['data']
    return config

def configure_device(connection_params, config_data, template_name):
    # Load the jinja2 templates and process the template to build XML config
    j2_tmp = jinja2.Environment(
        loader=jinja2.FileSystemLoader(searchpath='./'))
    template = j2_tmp.get_template(template_name)
    config = template.render(config_data)

    # Push XML configuration to network device
    with manager.connect(**connection_params) as connection:
        response = connection.edit_config(target='running', config=config)

def main():
    # Login information for the router
    connection_params = {
        'host': '172.31.55.203',
        'username': 'cisco',
        'password': 'cisco',
        'hostkey_verify': False,
    }

    # The data we want to push. We can define this structure
    # however it makes sense for our environment.
    config_data = {
        'loopbacks': [
            {
                'number': '42518',
                'description': 'No IP on this one yet!'
            },
            {
                'number': '53592',
                'ipv4_address': '192.0.2.1',
                'ipv4_mask': '255.255.255.0'
            }
        ]
    }

    # Get the configuration before making changes
    config = get_config(connection_params)

    # Print a subset of available configuration information
    sw_version = config['native']['version']
    hostname = config['native']['hostname']
    top_keys = list(config['native'].keys())
    print(f'SW version: {sw_version}')
    print(f'Hostname: {hostname}')
    print(f'top level keys: {top_keys}')

    # Configure the device using parameters defined above
    configure_device(connection_params=connection_params,
        config_data=config_data, template_name='loopbacks.j2')

if __name__ == '__main__':
    main()
\end{minted}

The file below is a jinja2 template file. Jinja2 is a text templating language
commonly used with Python applications and their derivative products, such as
Ansible. It contains basic programming logic such as conditionals, iteration,
and variable substitution. By substituting variables into an XML template, the
output is a data structure that NETCONF can push to the devices. The variable
fields have been highlighted to show the relevant logic.

\begin{minted}{xml}
<config>
  <native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native">
    <interface>
      {% for loopback in loopbacks %}
      <Loopback>
          <name>{{ loopback.number }}</name>
          {% if loopback.description is defined %}
          <description>{{ loopback.description }}</description>
          {% endif %}
          {% if loopback.ipv4_address is defined %}
          <ip>
            <address>
                <primary>
                  <address>{{ loopback.ipv4_address }}</address>
                  <mask>{{ loopback.ipv4_mask }}</mask>
                </primary>
            </address>
          </ip>
          {% endif %}
      </Loopback>
      {% endfor %}
    </interface>
  </native>
</config>
\end{minted}

Before running the code, verify that \verb|netconf-yang| is configured as
explained during the NETCONF console demonstration, along with a privilege 15
user. The code above reveals that the demo username/password is cisco/cisco.
After running the code, the output below is printed to standard output. The
author has included the ``top level keys'' just to show a few other high level
options available. Collecting information via NETCONF is far superior to
CLI-based screen scraping via regular expressions for text parsing.

\begin{minted}{text}
[ec2-user@devbox]# python3 pynetconf.py 
SW version: 16.9
Hostname: CSR1000v
top level keys: ['@xmlns', 'version', 'boot-start-marker', 'boot-end-marker',
'service', 'platform', 'hostname', 'username', 'vrf', 'ip', 'interface',
'control-plane', 'logging', 'multilink', 'redundancy', 'spanning-tree',
'subscriber', 'crypto', 'license', 'line', 'iox', 'diagnostic']
\end{minted}

For those who are also logged into the router via SSH, the log message below
will be generated when the NETCONF client accesses the device. This can be
useful for troubleshooting unexpected changes or rogue NETCONF logins.

\begin{minted}{text}
%DMI-5-AUTH_PASSED: R0/0: dmiauthd: User 'cisco' authenticated successfully
from 172.31.61.35:47284 and was authorized for netconf over ssh. External groups: PRIV15
\end{minted}

Using basic show commands, verify that the two loopbacks were added
successfully. The nested dictionary above indicates that Loopback 42518 has a
description defined by no IP addresses. Likewise, Loopback 53592 has an IPv4
address and subnet mask defined, but no description. The Jinja2 template
supplied, which generates the XML configuration to be pushed to the router,
makes both of these parameters optional.

\begin{minted}{text}
CSR1000v#show running-config interface Loopback42518
interface Loopback42518
 description No IP on this one yet!
 no ip address

CSR1000v#show running-config interface Loopback53592
interface Loopback53592
 ip address 192.0.2.1 255.255.255.0
\end{minted}

Last, check the statistics to see the incoming NETCONF sessions and
corresponding incoming remote procedure calls (RPCs). This indicates that
everything is working correctly.

\begin{minted}{text}
CSR1000v#show netconf-yang statistics 
netconf-start-time  : 2018-12-09T01:04:44+00:00
in-rpcs             : 8
in-bad-rpcs         : 0
out-rpc-errors      : 0
out-notifications   : 0
in-sessions         : 4
dropped-sessions    : 0
in-bad-hellos       : 0
\end{minted}

\subsubsection{REST API on IOS-XE}
This section will detail a basic IOS XE REST API call to a Cisco router. While
there are more powerful GUIs to interact with the REST API on IOS XE devices,
this demonstration will use the \verb|curl| CLI utility, which is supported on
Linux, Mac, and Windows operating systems. These tests were conducted on a
Linux machine in Amazon Web Services (AWS) which was targeting a Cisco
CSR1000v. Before beginning, all of the relevant version information is shown
on the follow page for reference.

\begin{minted}{text}
RTR_CSR1#show version | include RELEASE  
Cisco IOS Software, CSR1000V Software (X86_64_LINUX_IOSD-UNIVERSALK9-M),
  Version 15.5(3)S4a, RELEASE SOFTWARE (fc1)

[root@ip-10-125-0-100 restapi]# uname -a
Linux ip-10-125-0-100.ec2.internal 3.10.0-514.16.1.el7.x86_64 #1 SMP
Fri Mar 10 13:12:32 EST 2017 x86_64 x86_64 x86_64 GNU/Linux

[root@ip-10-125-0-100 restapi]# curl -V
curl 7.29.0 (x86_64-redhat-linux-gnu) libcurl/7.29.0 NSS/3.21 [snip]
Protocols: dict file ftp ftps gopher http https [snip]
Features: AsynchDNS GSS-Negotiate IDN NTLM NTLM_WB SSL libz unix-sockets
\end{minted}

First, the basic configuration to enable the REST API feature on IOS XE
devices is shown below. A brief verification shows that the feature is enabled
and uses TCP port 55443 by default. This port number is important later as the
curl command will need to know it.

\begin{minted}{text}
interface GigabitEthernet1
 description MGMT INTERFACE
 ip address dhcp
 ! or a static IP address

virtual-service csr_mgmt
 ip shared host-interface GigabitEthernet1
 activate

ip http secure-server
transport-map type persistent webui HTTPS_WEBUI
 secure-server
transport type persistent webui input HTTPS_WEBUI

remote-management
 restful-api

RTR_CSR1#show virtual-service detail | section ^Proc|^Feat|estful  
Process               Status            Uptime           # of restarts
restful_api            UP         0Y 0W 0D  0:49: 7        0
Feature         Status                 Configuration
Restful API   Enabled, UP             port: 55443
                                      auto-save-timer: 30 seconds
                                      socket: unix:/usr/local/nginx/[snip]
                                      single-session: Disabled
\end{minted}

Using \verb|curl| for IOS XE REST API invocations requires a number of options. Those
options are summarized next. They are also described in the manual pages for
\verb|curl| (use the \verb|man curl| shell command). This specific
demonstration will be limited to obtaining an authentication token, posting a
QoS class-map configuration, and verifying that it was written.

\begin{minted}{text}
Main argument: /api/v1/qos/class-map

X: custom request is forthcoming

v: verbose. Prints all debugging output which is useful for troubleshooting and learning.

u: username:password for device login

H: Extra header needed to specify that JSON is being used. Every new POST
request must contain JSON in the body of the request. It is also used with
GET, POST, PUT, and DELETE requests after an authentication token has been obtained.

d: sends the specified data in an HTTP POST request

k: insecure. This allows curl to accept certificates not signed by a trusted
CA. For testing purposes, this is required to accept the router’s self-signed
certificate. It is not a good idea to use it in production networks.

3: force curl to use SSLv3 for the transport to the managed device. This can
be detrimental and should be used cautiously (discussed later).
\end{minted}

The first step is obtaining an authentication token. This allows the HTTPS
client to supply authentication credentials once, such as username/password,
and then can use the token for authentication for all future API calls. The
initial attempt at obtaining this token fails. This is a common error so the
troubleshooting to resolve this issue is described in this document. The two
HTTPS endpoints cannot communicate due to not supporting the same cipher
suites. Note that it is critical to specify the REST API port number (55443)
in the URL, otherwise the standard HTTPS server will respond on port 443 and
the request will fail.

\begin{minted}{text}
[root@ip-10-125-0-100 restapi]# curl -v \
>  -X POST https://csr1:55443/api/v1/auth/token-services \
>  -H "Accept:application/json" -u "ansible:ansible" -d "" -k -3

* About to connect() to csr1 port 55443 (#0)
*   Trying 10.125.1.11...
* Connected to csr1 (10.125.1.11) port 55443 (#0)
* Initializing NSS with certpath: sql:/etc/pki/nssdb
* NSS error -12286 (SSL_ERROR_NO_CYPHER_OVERLAP)
* Cannot communicate securely with peer: no common encryption algorithm(s).
* Closing connection 0
curl: (35) Cannot communicate securely with peer: no common encryption algorithm(s).
\end{minted}

Sometimes installing/update the following packages can solve the issue. In
this case, these updates did not help.

\begin{minted}{text}
[root@ip-10-125-0-100 restapi]# yum install -y nss nss-util nss-sysinit nss-tools
Loaded plugins: amazon-id, rhui-lb, search-disabled-repos
Package nss-3.28.4-1.0.el7_3.x86_64 already installed and latest version
Package nss-util-3.28.4-1.0.el7_3.x86_64 already installed and latest version
Package nss-sysinit-3.28.4-1.0.el7_3.x86_64 already installed and latest version
Package nss-tools-3.28.4-1.0.el7_3.x86_64 already installed and latest version
Nothing to do
\end{minted}

If that fails, curl the following website. It will return a JSON listing of
all ciphers supported by your current HTTPS client. Piping the output into
\verb|jq|, a popular utility for querying JSON structures, pretty-prints the JSON
output for human readability.

\begin{minted}{text}
[root@ip-10-125-0-100 restapi]# curl https://www.howsmyssl.com/a/check | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1417  100  1417    0     0   9572      0 --:--:-- --:--:-- --:--:--  9639
\end{minted}
\begin{minted}{json}
{
  "given_cipher_suites": [
    "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
    "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
    "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
    "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
    "TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
    "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
    "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
    "TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
    "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
    "TLS_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_RSA_WITH_AES_256_CBC_SHA",
    "TLS_RSA_WITH_AES_256_CBC_SHA256",
    "TLS_RSA_WITH_AES_128_GCM_SHA256",
    "TLS_RSA_WITH_AES_128_CBC_SHA",
    "TLS_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_RSA_WITH_RC4_128_SHA",
    "TLS_RSA_WITH_RC4_128_MD5"
  ],
  "ephemeral_keys_supported": true,
  "session_ticket_supported": false,
  "tls_compression_supported": false,
  "unknown_cipher_suite_supported": false,
  "beast_vuln": false,
  "able_to_detect_n_minus_one_splitting": false,
  "insecure_cipher_suites": {
    "TLS_RSA_WITH_RC4_128_MD5": [
      "uses RC4 which has insecure biases in its output"
    ],
    "TLS_RSA_WITH_RC4_128_SHA": [
      "uses RC4 which has insecure biases in its output"
    ]
  },
  "tls_version": "TLS 1.2",
  "rating": "Bad"
}
\end{minted}

The utility \verb|sslscan| can help find the problem. The issue is that the
CSR1000v only supports the TLSv1 versions of the ciphers, not the SSLv3
version. The curl command issued above forced curl to use SSLv3 with the
\verb|-3| option as prescribed by the documentation. This is a minor error in
the documentation which has been reported and may be fixed at the time of your
reading. This troubleshooting excursion is likely to have value for those
learning about REST APIs on IOS XE devices in a general sense, since
establishing HTTPS transport is a prerequisite. 

\begin{minted}{text}
[root@ip-10-125-0-100 ansible]# sslscan --version
		sslscan version 1.10.2 
		OpenSSL 1.0.1e-fips 11 Feb 2013

[root@ip-10-125-0-100 restapi]# sslscan csr1 | grep " RC4-SHA"
    RC4-SHA
    RC4-SHA
    RC4-SHA
    RC4-SHA
    Rejected  SSLv3  112 bits  RC4-SHA
    Accepted  TLSv1  112 bits  RC4-SHA
    Failed    TLS11  112 bits  RC4-SHA
    Failed    TLS12  112 bits  RC4-SHA
\end{minted}

Removing the \verb|-3| option will fix the issue. Using \verb|sslscan| was still
useful because, ignoring the RC4 cipher itself used with grep, one can note
that the TLSv1 variant was accepted while the SSLv3 variant was rejected,
which would suggest a lack of support for SSLv3 ciphers. It appears that the
\verb|TLS_DHE_RSA_WITH_AES_256_CBC_SHA| cipher was chosen for the connection
when the curl command is issued again. Below is the correct output from a
successful \verb|curl|.

\begin{minted}{text}
[root@ip-10-125-0-100 restapi]# curl -v -X \
>  POST https://csr1:55443/api/v1/auth/token-services \
>  -H "Accept:application/json" -u "ansible:ansible" -d "" -k

* About to connect() to csr1 port 55443 (#0)
*   Trying 10.125.1.11...
* Connected to csr1 (10.125.1.11) port 55443 (#0)
* Initializing NSS with certpath: sql:/etc/pki/nssdb
* skipping SSL peer certificate verification
* SSL connection using TLS_DHE_RSA_WITH_AES_256_CBC_SHA
* Server certificate:
* 	subject: CN=restful_api,ST=California,O=Cisco,C=US
* 	start date: May 26 05:32:46 2013 GMT
* 	expire date: May 24 05:32:46 2023 GMT
* 	common name: restful_api
* 	issuer: CN=restful_api,ST=California,O=Cisco,C=US
* Server auth using Basic with user 'ansible'
> POST /api/v1/auth/token-services HTTP/1.1
[snip]
> 
< HTTP/1.1 200 OK
< Server: nginx/1.4.2
< Date: Sun, 07 May 2017 16:35:18 GMT
< Content-Type: application/json
< Content-Length: 200
< Connection: keep-alive
< 
* Connection #0 to host csr1 left intact
{"kind": "object#auth-token", "expiry-time": "Sun May  7 16:50:18 2017",
"token-id": "YGSBUtzTpfK2QumIEk8dt9rXhHjZfAJSZXYXDXg162Q=",
"link": "https://csr1:55443/api/v1/auth/token-services/6430558689"}
\end{minted}

The final step is using an HTTPS POST request to write new data to the router.
One can embed the JSON text as a single line into the curl command using the
-d option. The command appears intimidating at a glance. Note the single
quotes ('') surrounding the JSON data with the -d option; these are required
since the keys and values inside the JSON structure have ``double quotes''.
Additionally, the username/password is omitted from the request, and
additional headers (-H) are applied to include the authentication token string
and the JSON content type.

\begin{minted}{text}
[root@ip-10-125-0-100 restapi]# curl -v -H "Accept:application/json" \
>  -H "X-Auth-Token: YGSBUtzTpfK2QumIEk8dt9rXhHjZfAJSZXYXDXg162Q=" \
>  -H "content-type: application/json" -X POST https://csr1:55443/api/v1/qos/class-map
>  -d '{"cmap-name": "CMAP_AF11","description": "QOS CLASS MAP FROM REST API CALL", \
>  "match-criteria": {"dscp": [{"value": "af11","ip": false}]}}' -k

* About to connect() to csr1 port 55443 (#0)
*   Trying 10.125.1.11...
* Connected to csr1 (10.125.1.11) port 55443 (#0)
* Initializing NSS with certpath: sql:/etc/pki/nssdb
* skipping SSL peer certificate verification
* SSL connection using TLS_DHE_RSA_WITH_AES_256_CBC_SHA
* Server certificate:
* 	subject: CN=restful_api,ST=California,O=Cisco,C=US
* 	start date: May 26 05:32:46 2013 GMT
* 	expire date: May 24 05:32:46 2023 GMT
* 	common name: restful_api
* 	issuer: CN=restful_api,ST=California,O=Cisco,C=US
> POST /api/v1/qos/class-map HTTP/1.1
> User-Agent: curl/7.29.0
[snip]
< HTTP/1.1 201 CREATED
< Server: nginx/1.4.2
< Date: Sun, 07 May 2017 16:48:05 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 0
< Connection: keep-alive
< Location: https://csr1:55443/api/v1/qos/class-map/CMAP_AF11
< 
* Connection #0 to host csr1 left intact
\end{minted}

This newly-configured class-map can be verified using an HTTPS GET request.
The data field is stripped to the empty string, POST is changed to GET, and
the class-map name is appended to the URL\@. The verbose option (-v) is omitted
for brevity. Writing this output to a file and using the jq utility can be a
good way to query for specific fields. Piping the output to \verb|tee| allows
it to be written to the screen and redirected to a file.

\begin{minted}{text}
[root@ip-10-125-0-100 restapi]# curl -H "Accept:application/json" \
>  -H "X-Auth-Token: YGSBUtzTpfK2QumIEk8dt9rXhHjZfAJSZXYXDXg162Q="
>  -H "content-type: application/json" \
>  -X GET https://csr1:55443/api/v1/qos/class-map/CMAP_AF11
>  -d "" -k | tee cmap_af11.json

  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   195  100   195    0     0    792      0 --:--:-- --:--:-- --:--:--   792
{"cmap-name": "CMAP_AF11", "kind": "object#class-map", "match-criteria":
{"dscp": [{"ip": false, "value": "af11"}]}, "match-type": "match-all",
"description": " QOS CLASS MAP FROM REST API CALL"}
\end{minted}

\begin{minted}{text}
[root@ip-10-125-0-100 restapi]# jq '.description' cmap_af11.json 
" QOS CLASS MAP FROM REST API CALL"
\end{minted}

Logging into the router to verify the request via CLI is a good idea while
learning, although using HTTPS GET verified the same thing.

\begin{minted}{text}
RTR_CSR1#show running-config class-map
[snip]
class-map match-all CMAP_AF11
  description QOS CLASS MAP FROM REST API CALL
 match dscp af11 
end
\end{minted}

\subsubsection{RESTCONF on IOS-XE}
RESTCONF is a relatively new API offered by Cisco IOS XE\@. RESTCONF is a new
API introduced into Cisco IOS XE 16.3.1 which has some characteristics of
NETCONF and the classic REST API\@. It uses HTTP/HTTPS for transport much like
the REST API, but appears to be simpler. It is like NETCONF in terms of its
usefulness for configuring devices using data modeled in YANG\@; it supports
JSON and XML formats for retrieved data. The version of the router is shown
below as it differs from the router used in other tests.

\begin{minted}{text}
DENALI#show version | include RELEASE
Cisco IOS Software [Denali], CSR1000V Software (X86_64_LINUX_IOSD-UNIVERSALK9-M),
Version 16.3.1a, RELEASE SOFTWARE (fc4)
\end{minted}

Enabling RESTCONF requires a single hidden command in global configuration,
shown below as simply \verb|restconf|. This feature is not TAC supported at
the time of this writing and should be used for experimentation only.
Additionally, a loopback interface with an IP address and description is
configured. For simplicity, RESTCONF testing will be limited to insecure HTTP
to demonstrate the capability without dealing with SSL/TLS ciphers.

\begin{minted}{text}
DENALI#show running-config | include restconf
restconf

DENALI#show running-config interface loopback 42518
interface Loopback42518
 description COOL INTERFACE
 ip address 172.16.192.168 255.255.255.255
\end{minted}

The \verb|curl| utility is useful with RESTCONF as it was with the class REST
API\@. The difference is that the data retrieval process is more intuitive.
First, we query the interface IP address, then the description. Both of the
URLs are simple and the overall curl command syntax is easy to understand. The
output comes back in easy-to-read XML which is convenient for machines that
will use this information. Some data is nested, like the IP address, as there
could be multiple IP addresses. Other data, like the description, need not be
nested as there is only ever one description per interface.

\begin{minted}{text}
[root@ip-10-125-0-100 ~]# curl \
>  http://denali/restconf/api/config/native/interface/Loopback/42518/ip/address \
>  -u "username:password"
\end{minted}

\begin{minted}{xml}
<address xmlns="http://cisco.com/ns/yang/ned/ios"
  xmlns:y="http://tail-f.com/ns/rest"
  xmlns:ios="http://cisco.com/ns/yang/ned/ios">
  <primary>
    <address>172.16.192.168</address>
    <mask>255.255.255.255</mask>
  </primary>
</address>
\end{minted}

\begin{minted}{text}
[root@ip-10-125-0-100 ~]# curl \
>  http://denali/restconf/api/config/native/interface/Loopback/42518/description \
>  -u "username:password"
\end{minted}

\begin{minted}{xml}
<description xmlns="http://cisco.com/ns/yang/ned/ios"
  xmlns:y="http://tail-f.com/ns/rest"
  xmlns:ios="http://cisco.com/ns/yang/ned/ios">COOL INTERFACE
</description>
\end{minted}

This section does not detail other HTTP operations such as POST, PUT, and
DELETE using RESTCONF\@. The feature is still very new and is tightly integrated
with postman, a tool that generates HTTP requests automatically.
